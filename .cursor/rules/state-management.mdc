---
description: React State Management - Best Practices 2025
globs:
  - "**/*.tsx"
  - "**/*.ts"
  - "**/*.jsx"
  - "**/*.js"
alwaysApply: true
---

# React State Management - Best Practices 2025

## Core Principles

- **Local by default, global on demand**
- Always start with the simplest solution (useState)
- Only escalate to a more complex solution when a real need arises
- Avoid over-engineering and premature abstractions
- **Golden Rule for Shareable State:** Would the user want to share this state via URL? â†’ Use Nuqs

## Quick Decision Tree

```
1. Is this state shareable via URL? (filters, pagination, search)
   â””â”€ YES â†’ ğŸ”µ Nuqs

2. NO â†’ Is it server data? (API, database)
   â””â”€ YES â†’ ğŸŸ£ TanStack Query

3. NO â†’ Is it a form? (login, create, edit)
   â””â”€ YES â†’ ğŸŸ¢ React Hook Form

4. NO â†’ Is it global to the app? (theme, cart)
   â”œâ”€ Temporary â†’ ğŸŸ¡ Jotai / Zustand
   â””â”€ Persisted â†’ ğŸŸ  Jotai with Storage / Zustand Persist

5. NO â†’ Is it shared between few components? (2-3 levels)
   â”œâ”€ < 3 levels â†’ Props drilling
   â””â”€ 3+ levels â†’ React Context

6. NO â†’ Local to component
   â””â”€ ğŸ”´ useState / useReducer
```

## Detailed Solutions

### 1. ğŸ”µ Nuqs - URL State Management â­ PRIORITY

**Use when:** State should be shareable via URL (filters, pagination, search, tabs)

**Why Nuqs over useSearchParams:**
- âŒ useSearchParams: 15 lines, no type safety, sync bugs
- âœ… Nuqs: 3 lines, type-safe, auto-sync

#### When to Use Nuqs

âœ… **Filters** - Product filters, table filters
âœ… **Pagination** - Current page, items per page
âœ… **Search** - Search queries
âœ… **Tabs** - Active tab
âœ… **Sorting** - Sort column and direction
âœ… **View modes** - Grid/List view
âœ… **Date ranges** - From/To dates
âœ… **Categories** - Selected category

**Golden Rule:** *Would the user want to share this state via URL?* â†’ Use Nuqs

### Basic Usage

```typescript
'use client';

import { useQueryState, parseAsString } from 'nuqs';

function SearchBar() {
  const [search, setSearch] = useQueryState(
    'search',
    parseAsString.withDefault('')
  );

  return (
    <input
      value={search}
      onChange={(e) => setSearch(e.target.value)}
      placeholder="Search..."
    />
  );
}
```

### Advanced Types

```typescript
import {
  useQueryState,
  parseAsString,
  parseAsInteger,
  parseAsBoolean,
  parseAsStringEnum,
  parseAsArrayOf,
} from 'nuqs';

// String
const [search, setSearch] = useQueryState(
  'search',
  parseAsString.withDefault('')
);

// Integer (pagination)
const [page, setPage] = useQueryState(
  'page',
  parseAsInteger.withDefault(1)
);

// Boolean (toggle)
const [isActive, setIsActive] = useQueryState(
  'active',
  parseAsBoolean.withDefault(false)
);

// Enum (tabs)
const [tab, setTab] = useQueryState(
  'tab',
  parseAsStringEnum(['overview', 'settings', 'users']).withDefault('overview')
);

// Array (multiple filters)
const [categories, setCategories] = useQueryState(
  'categories',
  parseAsArrayOf(parseAsString).withDefault([])
);
```

### Multiple Query States

```typescript
import { useQueryStates, parseAsString, parseAsInteger } from 'nuqs';

function ProductFilters() {
  const [filters, setFilters] = useQueryStates({
    search: parseAsString.withDefault(''),
    category: parseAsString,
    minPrice: parseAsInteger,
    maxPrice: parseAsInteger,
    page: parseAsInteger.withDefault(1),
  });

  return (
    <div>
      <input
        value={filters.search}
        onChange={(e) => setFilters({ search: e.target.value })}
      />
      <select
        value={filters.category || ''}
        onChange={(e) => setFilters({ category: e.target.value })}
      >
        {/* categories */}
      </select>
      {/* More filters... */}
    </div>
  );
}
```

### Server-Side Access

```typescript
// app/products/page.tsx
import { searchParamsCache } from './search-params';

export default async function ProductsPage({
  searchParams,
}: {
  searchParams: Record<string, string | string[] | undefined>;
}) {
  // Parse and validate server-side
  const { search, category, page } = searchParamsCache.parse(searchParams);

  // Fetch with validated params
  const products = await getProducts({ search, category, page });

  return <ProductList products={products} />;
}
```

```typescript
// app/products/search-params.ts
import { createSearchParamsCache, parseAsString, parseAsInteger } from 'nuqs/server';

export const searchParamsCache = createSearchParamsCache({
  search: parseAsString.withDefault(''),
  category: parseAsString,
  page: parseAsInteger.withDefault(1),
});
```

#### Benefits

- âœ… **Type-safe** - Full TypeScript support
- âœ… **Shareable** - Users can share URLs with state
- âœ… **Bookmarkable** - State persists in URL
- âœ… **SSR compatible** - Works with Server Components
- âœ… **Concise** - 3 lines vs 15 lines of useSearchParams
- âœ… **No sync bugs** - Auto-syncs with URL

**Installation:** `npm install nuqs`

---

### 2. ğŸŸ£ TanStack Query - Server Data (Client Components)

**Use when:** Fetching data from API or database in Client Components

**âš ï¸ IMPORTANT:** For Next.js App Router, prefer **Server Components** when possible:
- âœ… Server Component: `async function Page() { const data = await fetchData(); }`
- âœ… Client Component: Use TanStack Query if you need interactivity

#### When to Use TanStack Query

âœ… **Client Components needing API data** - When you can't use Server Components
âœ… **Product lists with real-time updates** - API data with cache
âœ… **User profile with refresh** - Server data with auto-refresh
âœ… **Feature flags** - Remote config
âœ… **Any API data in Client Components** - With cache & invalidation

**Golden Rule:** *Server data should NEVER be duplicated in client state (useState, Zustand)*
**Golden Rule:** *NEVER use useEffect + fetch for server data â†’ Use TanStack Query or Server Component*

#### Basic Usage

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

function ProductList() {
  // âœ… Single source of truth for server data
  const { data: products, isLoading } = useQuery({
    queryKey: ['products'],
    queryFn: fetchProducts,
  });

  if (isLoading) return <Spinner />;
  return <div>{products.map(...)}</div>;
}

function ProductActions() {
  const queryClient = useQueryClient();
  
  const mutation = useMutation({
    mutationFn: createProduct,
    onSuccess: () => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: ['products'] });
    },
  });

  return <button onClick={() => mutation.mutate(data)}>Create</button>;
}
```

#### Anti-Pattern

```typescript
// âŒ BAD - Duplicating server data in client state
function UserProfile({ userId }) {
  const { data } = useQuery(['user', userId], fetchUser);
  const [user, setUser] = useState(data); // âŒ Unnecessary duplicate
}

// âœ… GOOD - TanStack Query as single source
function UserProfile({ userId }) {
  const { data: user } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
  });
}
```

#### Benefits

- âœ… **Automatic caching** - No manual cache management
- âœ… **Auto invalidation** - Refetch on mutations
- âœ… **Loading/error states** - Built-in
- âœ… **Optimistic updates** - Better UX
- âœ… **Single source of truth** - No state duplication

**Installation:** `npm install @tanstack/react-query`

---

### 3. ğŸŸ¢ React Hook Form - Form State

**Use when:** Managing form input and validation

### When to Use React Hook Form

âœ… **Create forms** - User registration, product creation
âœ… **Edit forms** - Profile editing, settings
âœ… **Multi-step forms** - Wizards, onboarding
âœ… **Complex validation** - Cross-field validation
âœ… **File uploads** - Forms with file inputs

### Basic Usage

```typescript
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { CreateUserSchema } from '@/domain/users/models/user';

function UserForm() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm({
    resolver: zodResolver(CreateUserSchema),
  });

  const onSubmit = async (data) => {
    await createUser(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('email')} />
      {errors.email && <span>{errors.email.message}</span>}
      
      <input {...register('name')} />
      {errors.name && <span>{errors.name.message}</span>}
      
      <button type="submit">Create</button>
    </form>
  );
}
```

#### Benefits

- âœ… **Validation** - Built-in validation with Zod
- âœ… **Performance** - Minimal re-renders (uncontrolled inputs)
- âœ… **Error handling** - Easy error display
- âœ… **Complex forms** - Handles arrays, nested objects

**Installation:** `npm install react-hook-form @hookform/resolvers zod`

---

### 4. ğŸŸ¡ Jotai / Zustand - Global Client State

**Use when:** Global state shared across the app (temporary, not persisted)

#### When to Use Jotai/Zustand

âœ… **UI theme** - Light/dark mode (temporary session)
âœ… **Temporary cart** - Shopping cart (before checkout)
âœ… **Session preferences** - UI preferences not persisted
âœ… **Global UI state** - Sidebar open, notifications

**Rule:** Prefer atomic stores rather than centralized mega-store

#### Jotai (Atomic)

```typescript
import { atom, useAtom } from 'jotai';

// âœ… Atomic - each atom is independent
const cartAtom = atom([]);
const themeAtom = atom('light');

function Cart() {
  const [items, setItems] = useAtom(cartAtom);
  return <div>{items.length} items</div>;
}
```

#### Zustand (Store-based)

```typescript
import { create } from 'zustand';

// âœ… Slice-focused store
const useCartStore = create((set) => ({
  items: [],
  addItem: (item) => set((state) => ({ items: [...state.items, item] })),
  clearCart: () => set({ items: [] }),
}));

function Cart() {
  const items = useCartStore((state) => state.items);
  const addItem = useCartStore((state) => state.addItem);
  return <div>{items.length} items</div>;
}
```

**Installation:**
- Jotai: `npm install jotai`
- Zustand: `npm install zustand`

---

### 5. ğŸŸ  Jotai with Storage / Zustand Persist - Persisted Global State

**Use when:** Global state that persists between sessions

#### When to Use Persisted State

âœ… **Dark mode** - User preference across sessions
âœ… **Language** - User language setting
âœ… **Sort/filter preferences** - Persisted filters
âœ… **User settings** - App configuration

**Rule:** Handle SSR rehydration properly (avoid hydration mismatches)

#### Jotai with Storage

```typescript
import { atomWithStorage } from 'jotai/utils';

// âœ… Persisted in localStorage
const darkModeAtom = atomWithStorage('darkMode', false);

function ThemeToggle() {
  const [isDark, setIsDark] = useAtom(darkModeAtom);
  return <button onClick={() => setIsDark(!isDark)}>Toggle</button>;
}
```

#### Zustand Persist

```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

const useSettingsStore = create(
  persist(
    (set) => ({
      theme: 'light',
      setTheme: (theme) => set({ theme }),
    }),
    {
      name: 'user-settings',
      // For SSR: handle rehydration
      skipHydration: true, // or custom getStorage
    }
  )
);
```

**SSR Considerations:**
- Use `skipHydration: true` or conditional `getStorage`
- Avoid hydration mismatches (client/server different values)

---

### 6. ğŸŸ¤ React Context - Shared State (Few Components)

**Use when:** State shared between parent and few close children

#### When to Use Context

âœ… **Multi-step form** - Shared data across steps
âœ… **Wizard** - Shared state in 3+ nested levels
âœ… **Feature-specific** - Limited scope (not app-wide)

**Rule:** 
- < 3 levels â†’ Props drilling is better
- 3+ levels â†’ Context is acceptable
- Watch out for unnecessary re-renders

#### Basic Usage

```typescript
import { createContext, useContext, useState } from 'react';

type FormContextType = {
  formData: FormData;
  setFormData: (data: FormData) => void;
};

const FormContext = createContext<FormContextType | null>(null);

function FormProvider({ children }) {
  const [formData, setFormData] = useState({});
  return (
    <FormContext.Provider value={{ formData, setFormData }}>
      {children}
    </FormContext.Provider>
  );
}

function useFormContext() {
  const context = useContext(FormContext);
  if (!context) throw new Error('useFormContext must be within FormProvider');
  return context;
}
```

**Anti-Pattern:**
- âŒ Creating Context "just in case" when useState would suffice
- âŒ App-wide Context that causes unnecessary re-renders

---

### 7. ğŸ”´ useState / useReducer - Local UI State

**Use when:** State is purely local and not shareable

### When to Use useState

âœ… **Modals** - Open/closed state
âœ… **Toggles** - Show/hide elements
âœ… **Hover states** - UI feedback
âœ… **Loading states** - Local loading indicators
âœ… **Form inputs** (simple) - Single input without validation

#### Basic Usage

```typescript
'use client';

import { useState } from 'react';

function Modal() {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <>
      <button onClick={() => setIsOpen(true)}>Open</button>
      {isOpen && (
        <div className="modal">
          {/* Modal content */}
          <button onClick={() => setIsOpen(false)}>Close</button>
        </div>
      )}
    </>
  );
}
```

#### useReducer for Complex State

```typescript
import { useReducer } from 'react';

function complexReducer(state, action) {
  switch (action.type) {
    case 'INCREMENT': return { count: state.count + 1 };
    case 'DECREMENT': return { count: state.count - 1 };
    default: return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(complexReducer, { count: 0 });
  return <button onClick={() => dispatch({ type: 'INCREMENT' })}>{state.count}</button>;
}
```

**Rule:** Start with useState. Use useReducer only if state logic is complex.

---

## Comparison Table

| Use Case | Tool | Reason |
|----------|------|--------|
| Search bar | ğŸ”µ Nuqs | Shareable, bookmarkable |
| Product filters | ğŸ”µ Nuqs | User wants to share filtered view |
| Pagination | ğŸ”µ Nuqs | User wants to share specific page |
| Active tab | ğŸ”µ Nuqs | Deep linking to specific tab |
| Sort column | ğŸ”µ Nuqs | Shareable sorting state |
| Product list (API) | ğŸŸ£ TanStack Query | Server data with cache |
| User profile (API) | ğŸŸ£ TanStack Query | Auto-refresh, invalidation |
| Create user form | ğŸŸ¢ RHF | Form with validation |
| Edit profile | ğŸŸ¢ RHF | Complex form with validation |
| Login form | ğŸŸ¢ RHF | Form with error handling |
| Dark mode (persisted) | ğŸŸ  Jotai Storage | Persisted preference |
| Language (persisted) | ğŸŸ  Zustand Persist | User setting |
| Cart (temporary) | ğŸŸ¡ Jotai/Zustand | Global temporary state |
| Theme (session) | ğŸŸ¡ Jotai/Zustand | Global UI state |
| Multi-step form | ğŸŸ¤ Context | Shared across steps |
| Modal open/close | ğŸ”´ useState | Pure UI state |
| Dropdown open | ğŸ”´ useState | Pure UI state |
| Loading spinner | ğŸ”´ useState | Local loading state |
| Hover effect | ğŸ”´ useState | Pure UI interaction |

## Real-World Examples

### Example 1: Product Listing with Filters

```typescript
'use client';

import { useQueryStates, parseAsString, parseAsInteger } from 'nuqs';

export function ProductFilters() {
  const [filters, setFilters] = useQueryStates({
    search: parseAsString.withDefault(''),
    category: parseAsString,
    minPrice: parseAsInteger,
    maxPrice: parseAsInteger,
    sort: parseAsString.withDefault('name'),
    page: parseAsInteger.withDefault(1),
  });

  return (
    <div className="filters">
      {/* Search */}
      <input
        type="search"
        value={filters.search}
        onChange={(e) => setFilters({ search: e.target.value, page: 1 })}
        placeholder="Search products..."
      />

      {/* Category */}
      <select
        value={filters.category || ''}
        onChange={(e) => setFilters({ category: e.target.value, page: 1 })}
      >
        <option value="">All categories</option>
        <option value="electronics">Electronics</option>
        <option value="clothing">Clothing</option>
      </select>

      {/* Price range */}
      <input
        type="number"
        placeholder="Min price"
        value={filters.minPrice || ''}
        onChange={(e) => setFilters({ minPrice: parseInt(e.target.value) })}
      />
      <input
        type="number"
        placeholder="Max price"
        value={filters.maxPrice || ''}
        onChange={(e) => setFilters({ maxPrice: parseInt(e.target.value) })}
      />

      {/* Pagination */}
      <Pagination
        currentPage={filters.page}
        onPageChange={(page) => setFilters({ page })}
      />
    </div>
  );
}
```

### Example 2: Tabs with Deep Linking

```typescript
'use client';

import { useQueryState, parseAsStringEnum } from 'nuqs';

const tabs = ['overview', 'settings', 'billing'] as const;

export function ProfileTabs() {
  const [activeTab, setActiveTab] = useQueryState(
    'tab',
    parseAsStringEnum(tabs).withDefault('overview')
  );

  return (
    <div>
      <div className="tabs">
        {tabs.map((tab) => (
          <button
            key={tab}
            onClick={() => setActiveTab(tab)}
            className={activeTab === tab ? 'active' : ''}
          >
            {tab}
          </button>
        ))}
      </div>

      <div className="tab-content">
        {activeTab === 'overview' && <Overview />}
        {activeTab === 'settings' && <Settings />}
        {activeTab === 'billing' && <Billing />}
      </div>
    </div>
  );
}
```

### Example 3: Combined (Nuqs + RHF)

```typescript
'use client';

import { useQueryState, parseAsInteger } from 'nuqs';
import { useForm } from 'react-hook-form';

export function UserManagement() {
  // URL state for pagination (shareable)
  const [page, setPage] = useQueryState(
    'page',
    parseAsInteger.withDefault(1)
  );

  // Form state for creating user (not shareable)
  const { register, handleSubmit } = useForm();

  const onCreateUser = async (data) => {
    await createUser(data);
    // Refresh list...
  };

  return (
    <div>
      {/* Create form - RHF */}
      <form onSubmit={handleSubmit(onCreateUser)}>
        <input {...register('email')} />
        <input {...register('name')} />
        <button type="submit">Create User</button>
      </form>

      {/* User list with pagination - Nuqs */}
      <UserList page={page} />
      <Pagination page={page} onPageChange={setPage} />
    </div>
  );
}
```

## Anti-Patterns to Avoid

### âŒ Creating Context "just in case"

```typescript
// âŒ Bad - Unnecessary Context
const ThemeContext = createContext();
// When useState would suffice

// âœ… Good - useState for local state
const [theme, setTheme] = useState('light');
```

### âŒ Centralized mega-store

```typescript
// âŒ Bad - Everything in one store
const useAppStore = create((set) => ({
  user: {},
  products: [],
  cart: [],
  theme: 'light',
  // ... 50 more properties
}));

// âœ… Good - Atomic stores
const useUserStore = create(...);
const useCartStore = create(...);
const themeAtom = atom('light');
```

### âŒ Duplicating server data in client state

```typescript
// âŒ Bad - Duplicating TanStack Query data
const { data } = useQuery(['products'], fetchProducts);
const [products, setProducts] = useState(data); // âŒ Unnecessary

// âœ… Good - TanStack Query as single source
const { data: products } = useQuery(['products'], fetchProducts);
```

### âŒ useState + useEffect for server data

```typescript
// âŒ Bad - Manual API state management with useEffect
const [products, setProducts] = useState([]);
const [loading, setLoading] = useState(false);
useEffect(() => {
  setLoading(true);
  fetchProducts().then(setProducts).finally(() => setLoading(false));
}, []);

// âœ… Good Option 1 - Next.js App Router Server Component (preferred)
// app/products/page.tsx (Server Component - no 'use client')
export default async function ProductsPage() {
  const products = await getProducts(); // Direct fetch, no useEffect
  return <ProductList products={products} />;
}

// âœ… Good Option 2 - TanStack Query (for Client Components)
'use client';
import { useQuery } from '@tanstack/react-query';

function ProductList() {
  const { data: products, isLoading } = useQuery({
    queryKey: ['products'],
    queryFn: fetchProducts,
  });
  // ...
}

// âœ… Good Option 3 - React 19 'use' hook (for Client Components)
'use client';
import { use } from 'react';

function ProductList({ productsPromise }: { productsPromise: Promise<Product[]> }) {
  const products = use(productsPromise); // Suspense-enabled
  return <div>{products.map(...)}</div>;
}
```

**Priority order for Next.js App Router:**
1. **Server Component** (async/await) - Best performance, no client JS
2. **TanStack Query** - If you need Client Component features (interactivity, real-time updates)
3. **React 'use' hook** - If you have a Promise from Server Component

### âŒ Context for local UI

```typescript
// âŒ Bad - Context for purely local state
const ModalContext = createContext();

// âœ… Good - useState for local UI
const [isOpen, setIsOpen] = useState(false);
```

### âŒ Manual localStorage management

```typescript
// âŒ Bad - Manual localStorage
const [theme, setTheme] = useState(() => localStorage.getItem('theme'));
useEffect(() => {
  localStorage.setItem('theme', theme);
}, [theme]);

// âœ… Good - Use atomWithStorage or persist
const darkModeAtom = atomWithStorage('darkMode', false);
```

### âŒ Manual URL state management

```typescript
// âŒ Bad - Manual useSearchParams (15 lines, bugs)
const [searchParams, setSearchParams] = useSearchParams();
const [search, setSearch] = useState('');
useEffect(() => {
  const q = searchParams.get('search');
  if (q !== search || !q) setSearch(q);
}, [searchParams]);

// âœ… Good - Use nuqs (3 lines, type-safe)
const [search, setSearch] = useQueryState('search', parseAsString.withDefault(''));
```

### âŒ Nuqs for form inputs

```typescript
// âŒ Bad - Don't put form data in URL
const [email, setEmail] = useQueryState('email');
const [password, setPassword] = useQueryState('password');

// âœ… Good - Use React Hook Form
const { register } = useForm();
```

### âŒ Nuqs for sensitive data

```typescript
// âŒ Bad - Sensitive data in URL
const [creditCard, setCreditCard] = useQueryState('cc');

// âœ… Good - Keep sensitive data local
const { register } = useForm();
```

### âŒ Ignoring SSR hydration issues

```typescript
// âŒ Bad - Hydration mismatch
const useStore = create(
  persist((set) => ({ theme: 'dark' }), { name: 'theme' })
);

// âœ… Good - Handle SSR properly
const useStore = create(
  persist(
    (set) => ({ theme: 'dark' }),
    { name: 'theme', skipHydration: true }
  )
);
```

## Decision Checklist

Before choosing a solution, ask these questions in order:

1. **Is this state shareable via URL?** (filters, pagination, search)
   â†’ ğŸ”µ **Nuqs**

2. **Is this data from the server?** (API, database)
   â†’ ğŸŸ£ **TanStack Query** (single source of truth)

3. **Is this a form?** (login, create, edit)
   â†’ ğŸŸ¢ **React Hook Form**

4. **Is this global to the app?**
   - Temporary session â†’ ğŸŸ¡ **Jotai / Zustand**
   - Persisted (localStorage) â†’ ğŸŸ  **Jotai Storage / Zustand Persist** (handle SSR)

5. **Shared with few components?** (2-3 levels)
   - < 3 levels â†’ **Props drilling**
   - 3+ levels â†’ ğŸŸ¤ **React Context** (watch re-renders)

6. **Local to component?**
   â†’ ğŸ”´ **useState / useReducer**

## Order of Increasing Complexity

1. `useState` â† **Start here**
2. Props drilling
3. `React.Context`
4. `Nuqs` (URL state)
5. `Jotai` / `Zustand`
6. `TanStack Query` + state management
7. Advanced combinations

**Final Rule:** Stay at the lowest level possible as long as it suffices. Only extend when the need arises.

## Visual Summary

```
useState          â†’ Local UI (modal, toggle)
Props drilling    â†’ Few components (< 3 levels)
Context           â†’ 3+ levels (multi-step form, watch re-renders)
Nuqs              â†’ URL state (filters, pagination, shareable â­)
Jotai/Zustand     â†’ Global client (cart, theme, temporary)
+ Storage         â†’ + Persisted (dark mode, preferences, handle SSR)
TanStack Query    â†’ Server data (API, cache, single source â­)
React Hook Form   â†’ Forms (login, checkout, validation â­)
```

## Installation

```bash
# Nuqs (URL state)
npm install nuqs

# TanStack Query (server data)
npm install @tanstack/react-query

# React Hook Form (forms)
npm install react-hook-form @hookform/resolvers zod

# Jotai (atomic state)
npm install jotai

# Zustand (store-based state)
npm install zustand
```

## Resources

- [Nuqs Documentation](https://nuqs.47ng.com/) - URL state management
- [TanStack Query Docs](https://tanstack.com/query/latest) - Server state
- [React Hook Form](https://react-hook-form.com/) - Forms
- [Jotai](https://jotai.org/) - Atomic state
- [Zustand](https://zustand-demo.pmnd.rs/) - Store-based state

## Summary

**Golden Rules:**

1. **Shareable via URL?** â†’ ğŸ”µ **Nuqs** (filters, pagination, search) â­
2. **Server data?** â†’ ğŸŸ£ **TanStack Query** (single source of truth) â­
3. **Form?** â†’ ğŸŸ¢ **React Hook Form** (validation) â­
4. **Global temporary?** â†’ ğŸŸ¡ **Jotai/Zustand**
5. **Global persisted?** â†’ ğŸŸ  **Jotai Storage/Zustand Persist** (handle SSR)
6. **Few components?** â†’ ğŸŸ¤ **Context** (watch re-renders) or Props drilling
7. **Local UI?** â†’ ğŸ”´ **useState** (default choice)

**Priority order:** Local by default â†’ Escalate only when needed â†’ Nuqs for shareable state

This ensures:
- âœ… Better UX (shareable states with Nuqs)
- âœ… Type safety (Nuqs + Zod + TypeScript)
- âœ… Cleaner code (right tool for the job)
- âœ… No over-engineering (start simple)
- âœ… Single source of truth (TanStack Query for server data)
