---
alwaysApply: true
---

# Environment Variables & API Keys Management (t3-env)

## Overview

This rule ensures proper management of environment variables and API keys using `@t3-oss/env-*` for typesafe, validated environment variables. This prevents hardcoding sensitive information and catches configuration errors at build time.

## Core Principles

1. **Never hardcode API keys or secrets** in source code
2. **Always use t3-env schema** for type-safe environment variables
3. **Document all environment variables** in `.env.example`
4. **Keep `.env` files out of version control** (ensure they're in `.gitignore`)
5. **Validate at build time** to catch missing/invalid variables early

## Installation

Choose the appropriate package for your framework:

```bash
# Next.js
pnpm add @t3-oss/env-nextjs

# Nuxt
pnpm add @t3-oss/env-nuxt

# Core (framework-agnostic)
pnpm add @t3-oss/env-core
```

Also install your validation library:

```bash
pnpm add zod
```

## Usage

### Step 1: Create Environment Schema

**MANDATORY**: When adding ANY API key or environment variable, follow these steps:

#### 1. Check if `src/env.ts` (or `env.mjs`) exists

- If not, create it at the appropriate location (root or package-specific in monorepo)

#### 2. Define your schema with t3-env

```typescript
// src/env.ts
import { createEnv } from "@t3-oss/env-nextjs"; // or @t3-oss/env-core
import { z } from "zod";

export const env = createEnv({
  /*
   * Server-side Environment variables, not available on the client.
   * Will throw if you access these variables on the client.
   */
  server: {
    DATABASE_URL: z.string().url(),
    STRIPE_API_KEY: z.string().min(1).startsWith("sk_"),
    OPENAI_API_KEY: z.string().min(1),
    JWT_SECRET: z.string().min(32),
    // Add new server-side variables here
  },

  /*
   * Environment variables available on the client (and server).
   *
   * ⚠️ NEXT_PUBLIC_ prefix required for Next.js client variables
   * ⚠️ VITE_ prefix required for Vite client variables
   * ⚠️ NUXT_PUBLIC_ prefix required for Nuxt client variables
   */
  client: {
    NEXT_PUBLIC_API_URL: z.string().url(),
    NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: z.string().min(1),
    // Add new client-side variables here
  },

  /*
   * Destructure all variables from process.env here.
   * This ensures they are included in the bundle and validates at build time.
   *
   * ⚠️ TypeScript will error if you forget to add a variable here
   */
  runtimeEnv: {
    DATABASE_URL: process.env.DATABASE_URL,
    STRIPE_API_KEY: process.env.STRIPE_API_KEY,
    OPENAI_API_KEY: process.env.OPENAI_API_KEY,
    JWT_SECRET: process.env.JWT_SECRET,
    NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL,
    NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY:
      process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY,
  },
});
```

#### 3. Update `.env.example`

Create or update `.env.example` with descriptive comments:

```bash
# Database connection string (PostgreSQL)
DATABASE_URL=

# Stripe API key for payment processing (starts with sk_)
STRIPE_API_KEY=

# OpenAI API key for AI features
OPENAI_API_KEY=

# JWT secret for authentication (minimum 32 characters)
JWT_SECRET=

# Public API URL (client-side)
NEXT_PUBLIC_API_URL=

# Clerk publishable key (client-side)
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=
```

#### 4. Create local `.env` file

Add actual values to `.env` (never commit this):

```bash
DATABASE_URL=postgresql://localhost:5432/mydb
STRIPE_API_KEY=sk_test_...
OPENAI_API_KEY=sk-...
JWT_SECRET=your-super-secret-jwt-key-min-32-chars
NEXT_PUBLIC_API_URL=http://localhost:3000
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_...
```

### Step 2: Use Environment Variables in Your Code

```typescript
// ✅ Correct - import from your env schema
import { env } from "@/env";

export const stripeService = {
  apiKey: env.STRIPE_API_KEY, // Type-safe, validated

  async createPayment() {
    // Use the typed environment variable
    const stripe = new Stripe(env.STRIPE_API_KEY);
    // ...
  }
};

// Client component
export const ClientComponent = () => {
  // Only NEXT_PUBLIC_ variables work here
  const apiUrl = env.NEXT_PUBLIC_API_URL; // ✅ Works
  // const dbUrl = env.DATABASE_URL; // ❌ Runtime error - server-only

  return <div>API: {apiUrl}</div>;
};

// ❌ Incorrect - don't use process.env directly
const apiKey = process.env.STRIPE_API_KEY; // No type safety, no validation
```

## Detection Triggers

Apply this rule when you encounter:

- API keys (prefixes: `sk_`, `pk_`, `api_key_`, etc.)
- OAuth secrets (`client_secret`, `oauth_token`)
- Database credentials (`DATABASE_URL`, `DB_HOST`, `DB_PASSWORD`)
- Third-party service credentials
- JWT secrets
- Encryption keys
- Any configuration values
- Public configuration (URLs, feature flags)

## Implementation Checklist

When adding a new environment variable:

- [ ] Add variable to appropriate section in `env.ts`:
  - `server` for server-side only (sensitive data)
  - `client` for public, client-accessible data
- [ ] Add Zod validation schema with appropriate constraints
- [ ] Add to `runtimeEnv` object (TypeScript will enforce this)
- [ ] Update `.env.example` with descriptive comment (create file if missing)
- [ ] Add actual value to `.env` (not committed)
- [ ] Import and use `env` object in code (never `process.env`)
- [ ] Ensure `.env` is in `.gitignore`
- [ ] Test that build fails with missing/invalid values

## Validation Best Practices

### Use Zod Refinements

```typescript
server: {
  // URL validation
  DATABASE_URL: z.string().url(),

  // String prefix validation
  STRIPE_API_KEY: z.string().startsWith("sk_"),

  // Minimum length
  JWT_SECRET: z.string().min(32),

  // Email validation
  ADMIN_EMAIL: z.string().email(),

  // Enum validation
  NODE_ENV: z.enum(["development", "staging", "production"]),

  // Number with range
  PORT: z.coerce.number().min(1000).max(65535).default(3000),

  // Boolean with default
  ENABLE_ANALYTICS: z.coerce.boolean().default(false),

  // Optional with fallback
  LOG_LEVEL: z.enum(["debug", "info", "warn", "error"]).default("info"),
}
```

### Use Transforms

```typescript
server: {
  // Transform comma-separated list to array
  ALLOWED_ORIGINS: z.string().transform(s => s.split(",")),

  // Transform string to number
  MAX_FILE_SIZE: z.string().transform(Number),

  // Transform and validate JSON
  FEATURE_FLAGS: z.string().transform(s => JSON.parse(s)),
}
```

## Framework-Specific Guidelines

### Next.js

```typescript
import { createEnv } from "@t3-oss/env-nextjs";

export const env = createEnv({
  server: {
    /* server vars */
  },
  client: {
    /* NEXT_PUBLIC_ vars */
  },
  runtimeEnv: {
    /* all vars */
  },
});
```

- Client variables **MUST** be prefixed with `NEXT_PUBLIC_`
- Server variables are stripped from client bundle automatically

### Nuxt

```typescript
import { createEnv } from "@t3-oss/env-nuxt";

export const env = createEnv({
  server: {
    /* server vars */
  },
  client: {
    /* NUXT_PUBLIC_ vars */
  },
  runtimeEnv: {
    /* all vars */
  },
});
```

- Client variables **MUST** be prefixed with `NUXT_PUBLIC_`

### Vite / Core

```typescript
import { createEnv } from "@t3-oss/env-core";

export const env = createEnv({
  server: {
    /* server vars */
  },
  client: {
    /* VITE_ vars */
  },
  clientPrefix: "VITE_",
  runtimeEnv: {
    // For Vite, use import.meta.env
    DATABASE_URL: process.env.DATABASE_URL,
    VITE_API_URL: import.meta.env.VITE_API_URL,
  },
});
```

## Monorepo Setup

### Shared Environment Variables

Create a shared env package:

```typescript
// packages/env/src/index.ts
import { createEnv } from "@t3-oss/env-core";
import { z } from "zod";

export const env = createEnv({
  server: {
    DATABASE_URL: z.string().url(),
    // Shared server variables
  },
  client: {},
  runtimeEnv: {
    DATABASE_URL: process.env.DATABASE_URL,
  },
});
```

### Package-Specific Variables

```typescript
// apps/web/src/env.ts
import { createEnv } from "@t3-oss/env-nextjs";
import { z } from "zod";

export const env = createEnv({
  extends: [baseEnv], // Extend shared config if needed
  server: {
    // Web-specific server vars
    STRIPE_API_KEY: z.string().min(1),
  },
  client: {
    // Web-specific client vars
    NEXT_PUBLIC_CLERK_KEY: z.string().min(1),
  },
  runtimeEnv: {
    STRIPE_API_KEY: process.env.STRIPE_API_KEY,
    NEXT_PUBLIC_CLERK_KEY: process.env.NEXT_PUBLIC_CLERK_KEY,
  },
});
```

## Common Patterns

### ✅ Good Practice

```typescript
// env.ts - Single source of truth
import { createEnv } from "@t3-oss/env-nextjs";
import { z } from "zod";

export const env = createEnv({
  server: {
    STRIPE_API_KEY: z.string().startsWith("sk_"),
    DATABASE_URL: z.string().url(),
  },
  client: {
    NEXT_PUBLIC_APP_URL: z.string().url(),
  },
  runtimeEnv: {
    STRIPE_API_KEY: process.env.STRIPE_API_KEY,
    DATABASE_URL: process.env.DATABASE_URL,
    NEXT_PUBLIC_APP_URL: process.env.NEXT_PUBLIC_APP_URL,
  },
});

// stripe.service.ts - Type-safe usage
import { env } from "@/env";

export class StripeService {
  private stripe = new Stripe(env.STRIPE_API_KEY);
  // TypeScript knows this is a string that starts with "sk_"
  // Build fails if STRIPE_API_KEY is missing or invalid
}
```

### ❌ Bad Practice

```typescript
// ❌ Direct process.env access - no validation
const apiKey = process.env.STRIPE_API_KEY;

// ❌ Hardcoded secrets
const apiKey = "sk_live_abc123xyz";

// ❌ Missing from env.ts but used in code
const secret = process.env.SOME_RANDOM_KEY;

// ❌ Client accessing server variable
// This will throw at runtime with t3-env
const dbUrl = env.DATABASE_URL; // in a client component
```

## Error Handling

t3-env will throw descriptive errors at **build time**:

```bash
❌ Invalid environment variables:
{
  STRIPE_API_KEY: [ 'Required' ],
  DATABASE_URL: [ 'Invalid url' ]
}
```

This prevents deploying with invalid configuration.

## Migration from process.env

1. Install `@t3-oss/env-*` and `zod`
2. Create `env.ts` with your schema
3. Find all `process.env.*` usages
4. Replace with `env.*` imports
5. Run build to catch any missing variables
6. Update `.env.example`

```bash
# Find all process.env usages
grep -r "process\.env\." --include="*.ts" --include="*.tsx"

# Replace with env imports
# Then update each file to import from @/env
```

## Integration with CI/CD

- Add all required variables to your CI/CD platform secrets
- Build will fail automatically if variables are missing/invalid
- No runtime surprises in production
- Document required variables in deployment notes

## Benefits of t3-env

✅ **Type safety**: Autocomplete and type checking for env variables
✅ **Build-time validation**: Catch errors before deployment
✅ **Runtime safety**: Prevents client access to server variables
✅ **Zero runtime overhead**: Validated once at startup
✅ **DX improvement**: No more typos or missing variables
✅ **Self-documenting**: Schema serves as documentation

## Resources

- [t3-env Documentation](https://env.t3.gg)
- [t3-env GitHub](https://github.com/t3-oss/t3-env)
- [Zod Documentation](https://zod.dev)
- [12-Factor App - Config](https://12factor.net/config)